Dining philosophers

#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
#include <vector>
using namespace std;

vector<unique_ptr<mutex>> f;   // store mutexes as unique_ptr

void p(int id,int n) {
    while (1) {
        cout << id << " thinking\n";
        this_thread::sleep_for(chrono::seconds(1));
        int l=id, r=(id+1)%n;
        lock(*f[l], *f[r]);
        lock_guard<mutex> L(*f[l], adopt_lock), R(*f[r], adopt_lock);
        cout << id << " eating\n";
        this_thread::sleep_for(chrono::seconds(1));
    }
}

int main() {
    int n;
    cout << "Enter number of philosophers: ";
    cin >> n;

    // create n mutexes
    for(int i=0;i<n;i++) f.push_back(make_unique<mutex>());

    vector<thread> t;
    for(int i=0;i<n;i++) t.emplace_back(p,i,n);
    for(auto& x:t) x.join();
}



First fit -Memory Allocation

#include <iostream>
using namespace std;

int main() {
    int b, p;
    cout << "Enter number of blocks: ";
    cin >> b;
    int block[b];

    cout << "Enter block sizes:\n";
    for(int i=0;i<b;i++) cin >> block[i];

    cout << "Enter number of processes: ";
    cin >> p;
    int process[p];
    cout << "Enter process sizes:\n";
    for(int i=0;i<p;i++) cin >> process[i];

    int alloc[p];
    for(int i=0;i<p;i++) alloc[i] = -1;   // -1 means not allocated

    // First Fit allocation
    for(int i=0;i<p;i++){
        for(int j=0;j<b;j++){
            if(block[j] >= process[i]){
                alloc[i] = j;
                block[j] -= process[i];  // reduce block size
                break;
            }
        }
    }

    cout << "\nProcess No.\tSize\tBlock No.\n";
    for(int i=0;i<p;i++){
        cout << i+1 << "\t\t" << process[i] << "\t";
        if(alloc[i] != -1) cout << alloc[i]+1;
        else cout << "Not Allocated";
        cout << endl;
    }
}





FCFS

#include <iostream>
#include <numeric>
using namespace std;

int main() {
    int n;
    cout << "Enter number of processes: ";
    cin >> n;

    int pid[50], bt[50], wt[50], tat[50];  // fixed-size arrays
    cout << "Enter process IDs and burst times:\n";
    for (int i = 0; i < n; i++) cin >> pid[i] >> bt[i];

    wt[0] = 0;
    for (int i = 1; i < n; i++) wt[i] = wt[i-1] + bt[i-1];
    for (int i = 0; i < n; i++) tat[i] = wt[i] + bt[i];

    cout << "\nPID\tBT\tWT\tTAT\n";
    for (int i = 0; i < n; i++)
        cout << pid[i] << "\t" << bt[i] << "\t" << wt[i] << "\t" << tat[i] << "\n";

    int totalWT = 0, totalTAT = 0;
    for (int i = 0; i < n; i++) {
        totalWT += wt[i];
        totalTAT += tat[i];
    }

    cout << "\nAverage WT = " << (float)totalWT / n;
    cout << "\nAverage TAT = " << (float)totalTAT / n << endl;
}
FIFO
#include <iostream>
using namespace std;

int main() {
    int frames[10], pages[30];
    int n, f, i, j, k, pageFaults = 0;

    cout << "Enter number of page frames: ";
    cin >> f;

    cout << "Enter number of page requests: ";
    cin >> n;

    cout << "Enter the page reference string:\n";
    for (i = 0; i < n; i++) cin >> pages[i];

    // Initialize frames with -1 (empty)
    for (i = 0; i < f; i++) frames[i] = -1;

    j = 0; // points to the oldest frame

    cout << "\nStep-by-step execution:\n";

    for (i = 0; i < n; i++) {
        int page = pages[i];
        bool found = false;

        // Check if page is already in frame
        for (k = 0; k < f; k++) {
            if (frames[k] == page) {
                found = true;
                break;
            }
        }

        if (!found) {
            // Replace using FIFO
            frames[j] = page;
            j = (j + 1) % f; // circular index
            pageFaults++;
            cout << "Page " << page << " caused a Page Fault. ";
        } else {
            cout << "Page " << page << " already in memory. No Page Fault. ";
        }

        // Print current frames
        cout << "Frames: [ ";
        for (k = 0; k < f; k++) {
            if (frames[k] != -1) cout << frames[k] << " ";
        }
        cout << "]\n";
    }

    cout << "\nTotal Page Faults = " << pageFaults << endl;

    return 0;
}

FCFS Disk Scheduling


#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, head, total = 0;
    cout << "Enter number of requests: ";
    cin >> n;
    int req[n];
    cout << "Enter the requests: ";
    for (int i = 0; i < n; i++) cin >> req[i];
    cout << "Enter head position: ";
    cin >> head;

    cout << "\nSequence: " << head;
    for (int i = 0; i < n; i++) {
        total += abs(head - req[i]);
        cout << " -> " << req[i];
        head = req[i];
    }
    cout << "\n\nTotal Head Movement = " << total;
}
Sequential File Organization

#include <fstream>
#include <iostream>
using namespace std;

int main() {
    int ch, id; string data, line;
    do {
        cout << "\n1.Write  2.Read  3.Exit: "; cin >> ch;
        if (ch == 1) {
            ofstream f("data.txt", ios::app);
            cout << "ID: "; cin >> id;
            cout << "Data: "; cin.ignore(); getline(cin, data);
            f << id << " " << data << "\n";
        } 
        else if (ch == 2) {
            ifstream f("data.txt");
            while (getline(f, line)) cout << line << "\n";
        }
    } while (ch != 3);
}
